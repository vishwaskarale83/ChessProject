<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CheckMate IQ</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sockjs-client/1.5.1/sockjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stomp.js/2.3.3/stomp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <link rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
      integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
      crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
        crossorigin="anonymous"></script>

    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
        integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
        crossorigin="anonymous"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
        }
        h1 {
            color: #333;
        }
        .page-nav {
            width: 100%;
            max-width: 480px;
            display: flex;
            justify-content: flex-start;
            margin: 24px 0 8px;
        }
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 999px;
            background: #ffffff;
            color: #1f2d3d;
            font-weight: 600;
            text-decoration: none;
            box-shadow: 0 6px 16px rgba(31, 45, 61, 0.12);
            border: 1px solid rgba(31, 45, 61, 0.12);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .back-link:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px rgba(31, 45, 61, 0.16);
            border-color: rgba(31, 120, 255, 0.4);
        }
        .back-link:focus-visible {
            outline: 3px solid rgba(31, 120, 255, 0.45);
            outline-offset: 2px;
        }
        .back-link-icon {
            width: 10px;
            height: 10px;
            border-left: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(45deg);
            margin-right: 2px;
        }
        #board {
            width: 480px;
            margin: 20px;
        }
        #turn {
            font-size: 18px;
            margin: 10px;
        }
        #message {
            width: 480px;
            font-size: 15px;
            color: #d9534f;
            margin: 4px 0 12px;
            min-height: 20px;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
        }
        .game-actions {
            width: 480px;
            display: flex;
            justify-content: center;
            gap: 12px;
            margin: 8px 0 16px;
        }
        .action-button {
            padding: 8px 18px;
            font-size: 15px;
            border-radius: 6px;
            border: none;
            background: #1f78ff;
            color: #ffffff;
            font-weight: 600;
            transition: background 0.2s ease, transform 0.2s ease;
        }
        .action-button:hover:not(:disabled) {
            background: #0f4fbf;
            transform: translateY(-1px);
        }
        .action-button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
        }
        .action-button.resign {
            background: #d9534f;
        }
        .action-button.resign:hover:not(:disabled) {
            background: #b12b27;
        }
        .dialog-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(23, 34, 45, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 16px;
        }
        .dialog-backdrop.visible {
            display: flex;
        }
        .dialog-box {
            width: 100%;
            max-width: 360px;
            background: #ffffff;
            border-radius: 12px;
            padding: 20px 22px;
            box-shadow: 0 14px 40px rgba(0, 0, 0, 0.18);
        }
        .dialog-box h3 {
            margin: 0 0 10px;
            font-size: 18px;
            color: #1f2d3d;
        }
        .dialog-box p {
            margin: 0;
            color: #44556a;
            line-height: 1.45;
        }
        .dialog-buttons {
            margin-top: 22px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        .dialog-button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }
        .dialog-button.primary {
            background: #1f78ff;
            color: #ffffff;
        }
        .dialog-button.primary:hover {
            background: #0f4fbf;
            transform: translateY(-1px);
        }
        .dialog-button.secondary {
            background: #e5e7eb;
            color: #1f2d3d;
        }
        .dialog-button.secondary:hover {
            background: #d1d5db;
            transform: translateY(-1px);
        }
        .dialog-button.danger {
            background: #d9534f;
            color: #ffffff;
        }
        .dialog-button.danger:hover {
            background: #b12b27;
            transform: translateY(-1px);
        }
        .dialog-buttons.promotion-choices {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 74px));
            justify-content: center;
            justify-items: center;
            gap: 14px;
        }
        .dialog-button.piece {
            width: 74px;
            height: 96px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 8px 12px;
            gap: 6px;
            background: #f5f8fc;
            border: 1px solid rgba(31, 120, 255, 0.2);
            color: #1f2d3d;
        }
        .dialog-button.piece:hover {
            background: rgba(31, 120, 255, 0.15);
        }
        .dialog-button.piece img {
            width: 48px;
            height: 48px;
            pointer-events: none;
        }
        .dialog-button.piece span {
            font-size: 13px;
            font-weight: 600;
        }
        .dialog-button.cancel-action {
            grid-column: 1 / -1;
            width: 100%;
            max-width: 220px;
            margin-top: 6px;
            justify-self: center;
        }
        .players {
            width: 480px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin: 12px 0;
        }
        .player-line {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: #ffffff;
            border-radius: 8px;
            padding: 6px 12px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.08);
        }
        .player-label {
            color: #2d3a4b;
            font-size: 16px;
        }
        .player-clock {
            min-width: 88px;
            text-align: right;
            font-family: "Courier New", Courier, monospace;
            font-size: 18px;
            font-weight: 600;
            color: #1c2733;
            padding: 4px 10px;
            border-radius: 6px;
            border: 1px solid rgba(0, 0, 0, 0.1);
            background: #f5f8fc;
        }
        .player-clock.active-clock {
            border-color: #1f78ff;
            background: rgba(31, 120, 255, 0.1);
            color: #0f4fbf;
        }
        .game-meta {
            width: 480px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin: 6px 0 4px;
            color: #2d3a4b;
            font-weight: 600;
        }
        .meta-item {
            font-size: 15px;
        }
        .highlight-move {
            box-shadow: inset 0 0 3px 3px yellow;
        }
        .highlight-last-from {
            box-shadow: inset 0 0 3px 3px rgba(255, 193, 7, 0.7);
        }
        .highlight-last-to {
            box-shadow: inset 0 0 3px 3px rgba(30, 144, 255, 0.65);
        }
    </style>
</head>
<body>
    <div class="page-nav">
        <a href="/games" class="back-link">
            <span class="back-link-icon" aria-hidden="true"></span>
            <span>Back to Games</span>
        </a>
    </div>
    <h1>Chess Game</h1>
    <div id="turn">Loading...</div>
    <div class="players" id="top-players"></div>
    <div id="board"></div>
    <div class="players" id="bottom-players"></div>
    <div class="game-meta">
        <span id="time-control-display" class="meta-item">Time control: --</span>
    </div>
    <div id="message"></div>
    <div class="game-actions">
        <button id="offer-draw-btn" class="action-button">Offer Draw</button>
        <button id="resign-btn" class="action-button resign">Resign</button>
    </div>
    
    <div id="dialog-backdrop" class="dialog-backdrop">
        <div class="dialog-box" role="dialog" aria-modal="true">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div id="dialog-buttons" class="dialog-buttons"></div>
        </div>
    </div>

    <script th:inline="javascript">
        let board = [];
        let boardWidget = null;
        let gameLogic = new Chess();
        let currentTurn = '';
        let stompClient = null;
        let gameId = [[${game.gameUuid}]];
        let currentUser = normalizeThymeleafValue('[[${currentUser.username}]]');
        let isAiGame = normalizeThymeleafValue('[[${game.gameType}]]') === 'HUMAN_VS_AI';
        let playerColor = normalizeThymeleafValue('[[${game.playerColor}]]'); // WHITE or BLACK
        playerColor = playerColor ? playerColor.toUpperCase() : null;
        let whitePlayerName = normalizeThymeleafValue('[[${game.whitePlayer != null ? game.whitePlayer.username : ''}]]');
        let blackPlayerName = normalizeThymeleafValue('[[${game.blackPlayer != null ? game.blackPlayer.username : ''}]]');
        let isWhitePlayer = (whitePlayerName && whitePlayerName === currentUser);
        let isBlackPlayer = (blackPlayerName && blackPlayerName === currentUser);
        let previousBoard = null;
        let lastMoveHighlights = [];
        let initialTimeSeconds = null;
        let whiteTimeRemaining = null;
        let blackTimeRemaining = null;
        let turnStartTimestamp = null;
        let timerInterval = null;
        let gameStatus = null;
        let localPlayerColor = isWhitePlayer ? 'WHITE' : (isBlackPlayer ? 'BLACK' : null);
        let offerDrawButton = null;
        let resignButton = null;
        let topPlayersContainer = null;
        let bottomPlayersContainer = null;
        let noticedDrawOfferFrom = null;
        let handledResultMessage = null;
        let claimedTimeoutForTurn = null;
        let dialogBackdrop = null;
        let dialogTitleEl = null;
        let dialogMessageEl = null;
        let dialogButtonsContainer = null;
        let dialogResolveFn = null;
        let promotionSelectionInProgress = false;
        let timeControlDisplayEl = null;
        let messageEl = null;
        
        console.log('isWhitePlayer:', isWhitePlayer, 'isBlackPlayer:', isBlackPlayer, 'currentUser:', currentUser, 'whitePlayer:', whitePlayerName, 'blackPlayer:', blackPlayerName, 'playerColor:', playerColor);

        function getBoardOrientation() {
            if (isWhitePlayer) {
                return 'white';
            }
            if (isBlackPlayer) {
                return 'black';
            }
            if (isAiGame && playerColor) {
                return playerColor === 'WHITE' ? 'white' : 'black';
            }
            return 'white';
        }

        function normalizeThymeleafValue(raw) {
            if (raw === null || raw === undefined) return '';
            if (typeof raw !== 'string') return raw;
            return raw.replace(/^['"]+|['"]+$/g, '').trim();
        }

        function rowColToAlgebraic(row, col) {
            const file = String.fromCharCode('a'.charCodeAt(0) + col);
            const rank = 8 - row;
            return file + rank;
        }

        const WHITE_PIECES = new Set(['♔', '♕', '♖', '♗', '♘', '♙']);
        const BLACK_PIECES = new Set(['♚', '♛', '♜', '♝', '♞', '♟']);

        function getPieceColorFromSymbol(symbol) {
            if (!symbol) return null;
            if (WHITE_PIECES.has(symbol)) return 'WHITE';
            if (BLACK_PIECES.has(symbol)) return 'BLACK';
            return null;
        }

        function normalizeSquareName(square) {
            if (!square || typeof square !== 'string') return null;
            return square.trim().toLowerCase();
        }

        const PROMOTION_MAP = {
            QUEEN: 'q',
            ROOK: 'r',
            BISHOP: 'b',
            KNIGHT: 'n'
        };
        const PROMOTION_TYPES = ['QUEEN', 'ROOK', 'BISHOP', 'KNIGHT'];

        function promotionImagePath(pieceColor, promotionType) {
            const prefix = pieceColor === 'b' ? 'b' : 'w';
            const code = PROMOTION_MAP[promotionType];
            if (!code) {
                return null;
            }
            return '/img/chesspieces/wikipedia/' + prefix + code + '.png';
        }

        function promotionLabel(promotionType) {
            return promotionType.charAt(0) + promotionType.slice(1).toLowerCase();
        }

        function buildPromotionButtonHtml(pieceColor, promotionType) {
            const imgSrc = promotionImagePath(pieceColor, promotionType);
            const label = promotionLabel(promotionType);
            if (!imgSrc) {
                return label;
            }
            return '<img src="' + imgSrc + '" alt="' + label + ' piece" /><span>' + label + '</span>';
        }

        function findMovesForDestination(source, target) {
            const moves = gameLogic.moves({ square: source, verbose: true });
            if (!moves || !moves.length) {
                return [];
            }
            return moves.filter(move => move.to === target);
        }

        function promptPromotionChoice(pieceColor) {
            if (promotionSelectionInProgress) {
                return Promise.resolve(null);
            }
            promotionSelectionInProgress = true;
            const colorLabel = pieceColor === 'b' ? 'Black' : 'White';
            const choiceButtons = PROMOTION_TYPES.map(type => ({
                html: buildPromotionButtonHtml(pieceColor, type),
                value: type,
                variant: 'piece',
                ariaLabel: 'Promote to ' + promotionLabel(type)
            }));
            choiceButtons.push({ label: 'Cancel', value: null, variant: 'secondary cancel-action' });
            return showDialog({
                title: colorLabel + ' pawn promotion',
                message: 'Select a piece to promote to.',
                buttons: choiceButtons,
                buttonsClass: 'promotion-choices'
            }).then(choice => {
                promotionSelectionInProgress = false;
                if (!choice || !PROMOTION_MAP[choice]) {
                    return null;
                }
                return choice;
            }).catch(() => {
                promotionSelectionInProgress = false;
                return null;
            });
        }

        function completeMove(source, target, promotionType) {
            const from = algebraicToRowCol(source);
            const to = algebraicToRowCol(target);
            if (!from || !to) {
                return false;
            }

            const moveRequest = { from: source, to: target };
            let promotionLabel = null;
            if (promotionType) {
                const chessPromotion = PROMOTION_MAP[promotionType];
                if (!chessPromotion) {
                    return false;
                }
                moveRequest.promotion = chessPromotion;
                promotionLabel = promotionType;
            }

            const move = gameLogic.move(moveRequest);
            if (move === null) {
                return false;
            }

            if (boardWidget) {
                const fenPlacement = gameLogic.fen().split(' ')[0];
                boardWidget.position(fenPlacement, false);
            }

            setLastMoveHighlights([source], [target]);
            makeMove(from.row, from.col, to.row, to.col, promotionLabel);
            return true;
        }

        function formatColorName(color) {
            if (!color || typeof color !== 'string') return '';
            const lower = color.toLowerCase();
            return lower.charAt(0).toUpperCase() + lower.slice(1);
        }

        function getTurnText() {
            if (!currentTurn) {
                return 'Loading turn...';
            }

            if (gameStatus && gameStatus !== 'ACTIVE') {
                if (gameStatus === 'WHITE_WON') return 'White won';
                if (gameStatus === 'BLACK_WON') return 'Black won';
                if (gameStatus === 'DRAW') return 'Draw';
                return formatColorName(currentTurn) + ' to move';
            }

            if (isWhitePlayer || isBlackPlayer) {
                const isPlayersTurn = (isWhitePlayer && currentTurn === 'WHITE') || (isBlackPlayer && currentTurn === 'BLACK');
                return isPlayersTurn ? 'Your Move' : "Opponent's move";
            }

            return formatColorName(currentTurn) + ' to move';
        }

        function isPlayerParticipant() {
            return localPlayerColor !== null;
        }

        function isStompConnected() {
            return stompClient && stompClient.connected;
        }

        function sendResign() {
            if (!isPlayerParticipant() || gameStatus !== 'ACTIVE') {
                return;
            }
            if (!isStompConnected()) {
                return;
            }
            showDialog({
                title: 'Resign Game',
                message: 'Are you sure you want to resign this game?',
                buttons: [
                    { label: 'Keep Playing', value: 'cancel', variant: 'secondary' },
                    { label: 'Resign', value: 'confirm', variant: 'danger' }
                ]
            }).then(result => {
                if (result === 'confirm') {
                    stompClient.send('/app/game/' + gameId + '/resign', {});
                }
            });
        }

        function sendDrawOffer() {
            if (!isPlayerParticipant() || gameStatus !== 'ACTIVE') {
                return;
            }
            if (!isStompConnected()) {
                return;
            }
            stompClient.send('/app/game/' + gameId + '/draw/offer', {});
        }

        function respondToDraw(accept) {
            if (!isStompConnected()) {
                return;
            }
            stompClient.send('/app/game/' + gameId + '/draw/respond', {}, JSON.stringify({ accept: !!accept }));
        }

        function updateActionButtons(game) {
            if (!offerDrawButton || !resignButton) {
                return;
            }
            const isActive = game.status === 'ACTIVE';
            const isHumanGame = game.gameType === 'HUMAN_VS_HUMAN';
            const bothPlayersSeated = !!game.whitePlayer && !!game.blackPlayer;
            const drawOfferBy = game.drawOfferBy;
            const isParticipant = isPlayerParticipant();

            resignButton.disabled = !(isActive && isParticipant);

            if (!isHumanGame || !isParticipant || !bothPlayersSeated || !isActive) {
                offerDrawButton.textContent = 'Offer Draw';
                offerDrawButton.disabled = true;
                return;
            }

            if (drawOfferBy) {
                if (drawOfferBy === localPlayerColor) {
                    offerDrawButton.textContent = 'Draw Offered';
                } else {
                    offerDrawButton.textContent = 'Responding...';
                }
                offerDrawButton.disabled = true;
            } else {
                offerDrawButton.textContent = 'Offer Draw';
                offerDrawButton.disabled = false;
            }
        }

        function handleIncomingDrawOffer(game) {
            const drawOfferBy = game.drawOfferBy;
            if (!drawOfferBy) {
                noticedDrawOfferFrom = null;
                return;
            }
            if (!isPlayerParticipant()) {
                return;
            }
            if (drawOfferBy === localPlayerColor) {
                noticedDrawOfferFrom = drawOfferBy;
                return;
            }
            if (noticedDrawOfferFrom === drawOfferBy) {
                return;
            }
            noticedDrawOfferFrom = drawOfferBy;
            const formatted = formatColorName(drawOfferBy);
            showDialog({
                title: formatted + ' Offers a Draw',
                message: 'Do you want to accept the draw offer?',
                buttons: [
                    { label: 'Decline', value: 'decline', variant: 'secondary' },
                    { label: 'Accept', value: 'accept', variant: 'primary' }
                ]
            }).then(result => {
                respondToDraw(result === 'accept');
            });
        }

        function ensureSentence(text) {
            if (!text) {
                return '';
            }
            const trimmed = text.toString().trim();
            if (!trimmed) {
                return '';
            }
            return /[.!?]$/.test(trimmed) ? trimmed : trimmed + '.';
        }

        function describeOutcomeReasonForPlayer(endType, didWin) {
            switch (endType) {
                case 'CHECKMATE':
                    return 'by checkmate';
                case 'RESIGNATION':
                    return didWin ? 'because your opponent resigned' : 'because you resigned';
                case 'TIMEOUT':
                    return didWin ? 'because your opponent ran out of time' : 'because you ran out of time';
                case 'KING_CAPTURE':
                    return didWin ? 'by king capture' : 'because your king was captured';
                default:
                    return '';
            }
        }

        function describeDrawReason(endType) {
            switch (endType) {
                case 'STALEMATE':
                    return 'by stalemate';
                case 'AGREED_DRAW':
                    return 'by agreement';
                case 'KING_CAPTURE':
                    return 'by double king capture';
                default:
                    return '';
            }
        }

        function buildResultDialogMessage(game) {
            if (!game || game.status !== 'FINISHED') {
                return null;
            }

            const lastMessage = game.lastMessage || 'Game over.';
            const result = game.result;

            if (!result || result === 'UNDECIDED') {
                return ensureSentence(lastMessage);
            }

            if (!isPlayerParticipant()) {
                return ensureSentence(lastMessage);
            }

            if (result === 'DRAW') {
                const drawReason = describeDrawReason(game.endType);
                if (drawReason) {
                    return ensureSentence('Game drawn ' + drawReason);
                }
                const ensuredLast = ensureSentence(lastMessage);
                return ensuredLast || ensureSentence('Game drawn');
            }

            const winnerColor = result === 'WHITE_WIN' ? 'WHITE' : 'BLACK';
            if (localPlayerColor !== 'WHITE' && localPlayerColor !== 'BLACK') {
                return ensureSentence(lastMessage);
            }

            const didWin = localPlayerColor === winnerColor;
            const reason = describeOutcomeReasonForPlayer(game.endType, didWin);
            if (reason) {
                return ensureSentence((didWin ? 'You won ' : 'You lost ') + reason);
            }

            const ensuredSentence = ensureSentence(didWin ? 'You won' : 'You lost');
            const ensuredLast = ensureSentence(lastMessage);
            if (ensuredLast && ensuredLast !== ensuredSentence) {
                return ensuredSentence + ' ' + ensuredLast;
            }
            return ensuredSentence;
        }

        function handleGameResult(game) {
            if (game.status === 'ACTIVE') {
                handledResultMessage = null;
                return;
            }

            if (game.status === 'FINISHED') {
                const dialogMessage = buildResultDialogMessage(game);
                if (dialogMessage && handledResultMessage !== dialogMessage) {
                    handledResultMessage = dialogMessage;
                    showDialog({
                        title: 'Game Over',
                        message: dialogMessage,
                        buttons: [{ label: 'OK', value: 'ok', variant: 'primary' }]
                    });
                }
            }
        }

        function shouldClaimTimeout(colorWhoseTurn, whiteSeconds, blackSeconds) {
            if (!isPlayerParticipant() || !isStompConnected()) {
                return false;
            }
            if (gameStatus !== 'ACTIVE') {
                return false;
            }
            if (!initialTimeSeconds || initialTimeSeconds <= 0) {
                return false;
            }
            if (colorWhoseTurn === 'WHITE' && (whiteSeconds === null || whiteSeconds > 0)) {
                return false;
            }
            if (colorWhoseTurn === 'BLACK' && (blackSeconds === null || blackSeconds > 0)) {
                return false;
            }
            return true;
        }

        function attemptTimeoutClaim(colorWhoseTurn) {
            if (claimedTimeoutForTurn === colorWhoseTurn) {
                return;
            }
            claimedTimeoutForTurn = colorWhoseTurn;
            stompClient.send('/app/game/' + gameId + '/timeout', {});
        }

        function hideDialog(result) {
            if (!dialogBackdrop) {
                return;
            }
            dialogBackdrop.classList.remove('visible');
            if (dialogButtonsContainer) {
                while (dialogButtonsContainer.firstChild) {
                    dialogButtonsContainer.removeChild(dialogButtonsContainer.firstChild);
                }
            }
            const resolver = dialogResolveFn;
            dialogResolveFn = null;
            if (resolver) {
                resolver(result);
            }
        }

        function showDialog(options) {
            if (!dialogBackdrop || !dialogTitleEl || !dialogMessageEl || !dialogButtonsContainer) {
                return Promise.resolve(options && options.buttons && options.buttons.length ? options.buttons[options.buttons.length - 1].value : null);
            }
            const dialogOptions = options || {};
            const buttons = (dialogOptions.buttons && dialogOptions.buttons.length) ? dialogOptions.buttons : [{ label: 'OK', value: 'ok', variant: 'primary' }];

            dialogTitleEl.textContent = dialogOptions.title || '';
            dialogMessageEl.textContent = dialogOptions.message || '';

            while (dialogButtonsContainer.firstChild) {
                dialogButtonsContainer.removeChild(dialogButtonsContainer.firstChild);
            }

            const extraClass = dialogOptions.buttonsClass ? ' ' + dialogOptions.buttonsClass : '';
            if (extraClass && dialogButtonsContainer) {
                dialogButtonsContainer.className = 'dialog-buttons' + extraClass;
            } else if (dialogButtonsContainer) {
                dialogButtonsContainer.className = 'dialog-buttons';
            }

            return new Promise(resolve => {
                dialogResolveFn = resolve;
                buttons.forEach(button => {
                    const btn = document.createElement('button');
                    if (button.html) {
                        btn.innerHTML = button.html;
                        if (button.ariaLabel) {
                            btn.setAttribute('aria-label', button.ariaLabel);
                        }
                    } else {
                        btn.textContent = button.label || 'OK';
                    }
                    const variantClass = button.variant ? ' ' + button.variant : ' primary';
                    btn.className = 'dialog-button' + variantClass;
                    btn.addEventListener('click', function() {
                        hideDialog(button.hasOwnProperty('value') ? button.value : null);
                    });
                    dialogButtonsContainer.appendChild(btn);
                });
                dialogBackdrop.classList.add('visible');
            });
        }

        function detectLastMoveSquares(previous, current, expectedColor) {
            if (!previous || !current || previous.length === 0 || current.length === 0) {
                return { from: [], to: [] };
            }

            const fromCandidates = [];
            const toCandidates = [];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const prevVal = previous[r][c];
                    const currVal = current[r][c];
                    if (prevVal === currVal) continue;

                    const prevEmpty = !prevVal;
                    const currEmpty = !currVal;
                    const prevColor = getPieceColorFromSymbol(prevVal);
                    const currColor = getPieceColorFromSymbol(currVal);

                    if (!prevEmpty && currEmpty) {
                        fromCandidates.push({ row: r, col: c, piece: prevVal, color: prevColor });
                    } else if (prevEmpty && !currEmpty) {
                        toCandidates.push({ row: r, col: c, piece: currVal, color: currColor });
                    } else if (!prevEmpty && !currEmpty && prevVal !== currVal) {
                        fromCandidates.push({ row: r, col: c, piece: prevVal, color: prevColor });
                        toCandidates.push({ row: r, col: c, piece: currVal, color: currColor });
                    }
                }
            }

            const selectCandidate = (candidates) => {
                if (!candidates.length) return null;
                if (expectedColor) {
                    const match = candidates.find(candidate => candidate.color === expectedColor);
                    if (match) return match;
                }
                return candidates[0];
            };

            const fromCandidate = selectCandidate(fromCandidates);
            const toCandidate = selectCandidate(toCandidates);

            const fromSquares = fromCandidate ? [rowColToAlgebraic(fromCandidate.row, fromCandidate.col)] : [];
            const toSquares = toCandidate ? [rowColToAlgebraic(toCandidate.row, toCandidate.col)] : [];
            return { from: fromSquares, to: toSquares };
        }

        function clearLastMoveHighlights() {
            lastMoveHighlights.forEach(entry => {
                const squareEl = document.querySelector('#board .square-' + entry.square);
                if (squareEl) {
                    squareEl.classList.remove(entry.className);
                }
            });
            lastMoveHighlights = [];
        }

        function setLastMoveHighlights(fromSquares, toSquares) {
            clearLastMoveHighlights();
            const unique = new Set();

            (fromSquares || []).forEach(square => {
                if (!square || unique.has(square + '|from')) return;
                const squareEl = document.querySelector('#board .square-' + square);
                if (squareEl) {
                    squareEl.classList.add('highlight-last-from');
                    lastMoveHighlights.push({ square: square, className: 'highlight-last-from' });
                    unique.add(square + '|from');
                }
            });

            (toSquares || []).forEach(square => {
                if (!square || unique.has(square + '|to')) return;
                const squareEl = document.querySelector('#board .square-' + square);
                if (squareEl) {
                    squareEl.classList.add('highlight-last-to');
                    lastMoveHighlights.push({ square: square, className: 'highlight-last-to' });
                    unique.add(square + '|to');
                }
            });
        }

        function connect() {
            let socket = new SockJS('/ws');
            stompClient = Stomp.over(socket);
            stompClient.connect({}, function(frame) {
                console.log('Connected: ' + frame);
                stompClient.subscribe('/topic/game/' + gameId, function(message) {
                    updateGame(JSON.parse(message.body));
                });
            });
        }

        function loadGame() {
            fetch('/api/game/' + gameId)
                .then(response => response.json())
                .then(data => updateGame(data));
        }

        const unicodeToFen = {
            '♔': 'K', '♕': 'Q', '♖': 'R', '♗': 'B', '♘': 'N', '♙': 'P',
            '♚': 'k', '♛': 'q', '♜': 'r', '♝': 'b', '♞': 'n', '♟': 'p'
        };

        function normalizeBoard(raw) {
            return raw.map(row => row.map(cell => {
                if (!cell) return '';
                if (cell.includes(',')) {
                    const parts = cell.split(',');
                    if (parts.length === 2) {
                        const type = parts[0];
                        const isWhite = parts[1] === 'WHITE';
                        switch (type) {
                            case 'KING': return isWhite ? '♔' : '♚';
                            case 'QUEEN': return isWhite ? '♕' : '♛';
                            case 'ROOK': return isWhite ? '♖' : '♜';
                            case 'BISHOP': return isWhite ? '♗' : '♝';
                            case 'KNIGHT': return isWhite ? '♘' : '♞';
                            case 'PAWN': return isWhite ? '♙' : '♟';
                            default: return '';
                        }
                    }
                }
                return cell; // already unicode
            }));
        }

        function boardToFen(boardState) {
            const rows = [];
            for (let r = 0; r < 8; r++) {
                let fenRow = '';
                let empty = 0;
                for (let c = 0; c < 8; c++) {
                    const cell = boardState[r][c];
                    if (!cell) {
                        empty++;
                    } else {
                        if (empty > 0) {
                            fenRow += empty;
                            empty = 0;
                        }
                        fenRow += unicodeToFen[cell] || '1';
                    }
                }
                if (empty > 0) {
                    fenRow += empty;
                }
                rows.push(fenRow);
            }
            return rows.join('/');
        }

        function algebraicToRowCol(square) {
            if (!square || square.length !== 2) return null;
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(square[1], 10);
            if (file < 0 || file > 7 || isNaN(rank) || rank < 1 || rank > 8) return null;
            
            // Board coordinates are always from white's perspective internally
            const row = 8 - rank;
            const col = file;
            return { row, col };
        }

        function updateGame(game) {
            const previousSnapshot = previousBoard ? previousBoard.map(row => row.slice()) : null;
            if (game.boardState) {
                const raw = JSON.parse(game.boardState);
                board = normalizeBoard(raw);
            } else {
                // Default board
                board = [
                    ['♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜'],
                    ['♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟'],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['', '', '', '', '', '', '', ''],
                    ['♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙'],
                    ['♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖']
                ];
            }
            
            currentTurn = game.currentTurn;
            gameStatus = game.status;
            claimedTimeoutForTurn = null;
            
            // Sync chess.js logic
            const placement = boardToFen(board);
            const turn = currentTurn === 'WHITE' ? 'w' : 'b';
            // Construct a FEN string. We assume full castling rights for now as backend doesn't persist them properly yet.
            const fen = `${placement} ${turn} KQkq - 0 1`;
            
            // Load position into chess.js to validate moves
            // Note: load() returns false if FEN is invalid, but we try our best
            const loaded = gameLogic.load(fen);
            if (!loaded) {
                console.warn('chess.js failed to load FEN:', fen);
                // Fallback: clear and setup manually or just rely on server?
                // We'll try to continue, but validation might be off.
            }

            renderBoard();

            let fromSquares = [];
            let toSquares = [];

            if (game.lastMoveFrom || game.lastMoveTo) {
                const serverFrom = normalizeSquareName(game.lastMoveFrom);
                const serverTo = normalizeSquareName(game.lastMoveTo);
                if (serverFrom) {
                    fromSquares.push(serverFrom);
                }
                if (serverTo) {
                    toSquares.push(serverTo);
                }
            } else {
                const lastMoverColor = game.lastMoveColor || (currentTurn === 'WHITE' ? 'BLACK' : 'WHITE');
                const diffSquares = detectLastMoveSquares(previousSnapshot, board, lastMoverColor);
                fromSquares = diffSquares.from;
                toSquares = diffSquares.to;
            }

            setLastMoveHighlights(fromSquares, toSquares);
            const turnElement = document.getElementById('turn');
            if (turnElement) {
                turnElement.textContent = getTurnText();
            }
            if (messageEl) {
                messageEl.textContent = game.lastMessage || '';
            }
            updateTimeControlDisplay(game);
            buildClockPanels(game);
            updateActionButtons(game);
            handleIncomingDrawOffer(game);
            handleGameResult(game);
            refreshClock(game);
            previousBoard = board.map(row => row.slice());
        }

        function renderBoard() {
            const fen = boardToFen(board);
            const orientation = getBoardOrientation();
            console.log('Board orientation set to:', orientation);
            
            const opts = {
                position: fen,
                draggable: true,
                orientation: orientation,
                pieceTheme: '/img/chesspieces/wikipedia/{piece}.png',
                onDrop: handleBoardDrop,
                onMouseoverSquare: onMouseoverSquare,
                onMouseoutSquare: onMouseoutSquare
            };
            if (!boardWidget) {
                boardWidget = Chessboard('board', opts);
            } else {
                boardWidget.orientation(orientation);
                boardWidget.position(fen, false);
            }
        }

        function onMouseoverSquare(square, piece) {
            // Get valid moves using chess.js
            const moves = gameLogic.moves({
                square: square,
                verbose: true
            });

            if (moves.length === 0) return;

            // Highlight target squares
            for (const move of moves) {
                highlightSquare(move.to);
            }
        }

        function onMouseoutSquare(square, piece) {
            removeHighlights();
        }

        function highlightSquare(square) {
            const $square = document.querySelector('.square-' + square);
            if ($square) {
                $square.classList.add('highlight-move');
            }
        }

        function removeHighlights() {
            const squares = document.querySelectorAll('.highlight-move');
            squares.forEach(el => el.classList.remove('highlight-move'));
        }

        function handleBoardDrop(source, target) {
            if (promotionSelectionInProgress) {
                return 'snapback';
            }
            if (source === target) return;

            const normalizedSource = normalizeSquareName(source);
            const normalizedTarget = normalizeSquareName(target);
            if (!normalizedSource || !normalizedTarget) {
                return 'snapback';
            }

            const matchingMoves = findMovesForDestination(normalizedSource, normalizedTarget);
            if (!matchingMoves.length) {
                return 'snapback';
            }

            const promotionMove = matchingMoves.find(move => !!move.promotion);
            if (promotionMove) {
                const movingPiece = gameLogic.get(normalizedSource);
                if (!movingPiece) {
                    return 'snapback';
                }
                promptPromotionChoice(movingPiece.color).then(choice => {
                    if (!choice) {
                        renderBoard();
                        return;
                    }
                    const successful = completeMove(normalizedSource, normalizedTarget, choice);
                    if (!successful) {
                        renderBoard();
                    }
                });
                return 'snapback';
            }

            const successful = completeMove(normalizedSource, normalizedTarget, null);
            if (!successful) {
                return 'snapback';
            }
        }

        function makeMove(fromRow, fromCol, toRow, toCol, promotion) {
            if (stompClient) {
                const payload = {
                    fromRow: fromRow,
                    fromCol: fromCol,
                    toRow: toRow,
                    toCol: toCol
                };
                if (promotion) {
                    payload.promotion = promotion;
                }
                stompClient.send('/app/game/' + gameId + '/move', {}, JSON.stringify(payload));
            }
        }

        function updateTimeControlDisplay(game) {
            if (!timeControlDisplayEl) {
                return;
            }
            const seconds = game && typeof game.initialTimeSeconds === 'number' ? game.initialTimeSeconds : null;
            timeControlDisplayEl.textContent = 'Time control: ' + formatTimeControlLabel(seconds);
        }

        function formatTimeControlLabel(totalSeconds) {
            if (!totalSeconds || totalSeconds <= 0) {
                return 'No clock';
            }
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const parts = [];
            if (minutes > 0) {
                parts.push(minutes + ' ' + (minutes === 1 ? 'minute' : 'minutes'));
            }
            if (seconds > 0) {
                parts.push(seconds + ' ' + (seconds === 1 ? 'second' : 'seconds'));
            }
            if (!parts.length) {
                parts.push(totalSeconds + ' seconds');
            }
            return parts.join(' ');
        }

        function refreshClock(game) {
            initialTimeSeconds = typeof game.initialTimeSeconds === 'number' ? game.initialTimeSeconds : null;
            whiteTimeRemaining = typeof game.whiteTimeRemainingSeconds === 'number' ? game.whiteTimeRemainingSeconds : null;
            blackTimeRemaining = typeof game.blackTimeRemainingSeconds === 'number' ? game.blackTimeRemainingSeconds : null;
            turnStartTimestamp = game.turnStartAt ? Date.parse(game.turnStartAt) : null;

            if (!initialTimeSeconds || initialTimeSeconds <= 0 || whiteTimeRemaining === null || blackTimeRemaining === null) {
                stopClockInterval();
                setClockText('white-clock', '--:--');
                setClockText('black-clock', '--:--');
                setActiveClock();
                return;
            }

            updateClockDisplay();
            stopClockInterval();
            if (gameStatus === 'ACTIVE') {
                timerInterval = setInterval(updateClockDisplay, 250);
            }
        }

        function updateClockDisplay() {
            if (!initialTimeSeconds || initialTimeSeconds <= 0) {
                return;
            }

            const now = Date.now();
            const whiteSeconds = computeDisplayedSeconds(whiteTimeRemaining, currentTurn === 'WHITE', now);
            const blackSeconds = computeDisplayedSeconds(blackTimeRemaining, currentTurn === 'BLACK', now);

            setClockText('white-clock', formatSeconds(whiteSeconds));
            setClockText('black-clock', formatSeconds(blackSeconds));
            setActiveClock();

            if (shouldClaimTimeout(currentTurn, whiteSeconds, blackSeconds)) {
                attemptTimeoutClaim(currentTurn);
            }

            if ((whiteSeconds !== null && whiteSeconds <= 0) || (blackSeconds !== null && blackSeconds <= 0) || gameStatus !== 'ACTIVE') {
                stopClockInterval();
            }
        }

        function computeDisplayedSeconds(baseSeconds, isActive, nowMillis) {
            if (typeof baseSeconds !== 'number') {
                return null;
            }
            let remaining = baseSeconds;
            if (isActive && turnStartTimestamp && gameStatus === 'ACTIVE') {
                const elapsed = Math.floor((nowMillis - turnStartTimestamp) / 1000);
                remaining = baseSeconds - elapsed;
            }
            return remaining < 0 ? 0 : remaining;
        }

        function setClockText(elementId, value) {
            const el = document.getElementById(elementId);
            if (!el) return;
            el.textContent = value !== null && value !== undefined ? value : '--:--';
        }

        function buildClockPanels(game) {
            if (!topPlayersContainer || !bottomPlayersContainer) {
                return;
            }

            const orientation = getBoardOrientation();
            const topColor = orientation === 'white' ? 'BLACK' : 'WHITE';
            const bottomColor = orientation === 'white' ? 'WHITE' : 'BLACK';

            topPlayersContainer.innerHTML = createPlayerMarkup(game, topColor, 'top');
            bottomPlayersContainer.innerHTML = createPlayerMarkup(game, bottomColor, 'bottom');
        }

        function createPlayerMarkup(game, color, position) {
            const isWhite = color === 'WHITE';
            const player = isWhite ? game.whitePlayer : game.blackPlayer;
            const isAiGame = game.gameType === 'HUMAN_VS_AI';
            const label = isWhite ? 'White' : 'Black';
            let name = '';
            if (player && player.username) {
                name = player.username;
            } else if (isAiGame) {
                name = 'Computer';
            } else {
                name = position === 'top' ? 'Waiting for opponent' : 'You';
            }

            const clockId = isWhite ? 'white-clock' : 'black-clock';
            return (
                '<div class="player-line">' +
                    '<div class="player-label">' +
                        '<span><strong>' + label + ':</strong> ' + (name || '') + '</span>' +
                    '</div>' +
                    '<div class="player-clock" id="' + clockId + '">--:--</div>' +
                '</div>'
            );
        }

        function stopClockInterval() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function setActiveClock() {
            const whiteClock = document.getElementById('white-clock');
            const blackClock = document.getElementById('black-clock');
            if (!whiteClock || !blackClock) return;
            const shouldHighlightWhite = initialTimeSeconds && initialTimeSeconds > 0 && gameStatus === 'ACTIVE' && currentTurn === 'WHITE';
            const shouldHighlightBlack = initialTimeSeconds && initialTimeSeconds > 0 && gameStatus === 'ACTIVE' && currentTurn === 'BLACK';
            whiteClock.classList.toggle('active-clock', shouldHighlightWhite);
            blackClock.classList.toggle('active-clock', shouldHighlightBlack);
        }

        function formatSeconds(totalSeconds) {
            if (totalSeconds === null || totalSeconds === undefined) {
                return '--:--';
            }
            const clamped = Math.max(0, Math.floor(totalSeconds));
            const minutes = Math.floor(clamped / 60);
            const seconds = clamped % 60;
            return minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
        }

        window.onload = function() {
            offerDrawButton = document.getElementById('offer-draw-btn');
            resignButton = document.getElementById('resign-btn');
            topPlayersContainer = document.getElementById('top-players');
            bottomPlayersContainer = document.getElementById('bottom-players');
            timeControlDisplayEl = document.getElementById('time-control-display');
            messageEl = document.getElementById('message');
            dialogBackdrop = document.getElementById('dialog-backdrop');
            dialogTitleEl = document.getElementById('dialog-title');
            dialogMessageEl = document.getElementById('dialog-message');
            dialogButtonsContainer = document.getElementById('dialog-buttons');
            if (dialogBackdrop) {
                dialogBackdrop.addEventListener('click', function(event) {
                    if (event.target === dialogBackdrop) {
                        hideDialog('dismiss');
                    }
                });
            }
            if (offerDrawButton) {
                offerDrawButton.addEventListener('click', function() {
                    sendDrawOffer();
                });
            }
            if (resignButton) {
                resignButton.addEventListener('click', function() {
                    sendResign();
                });
            }
            connect();
            loadGame();
        };
    </script>
</body>
</html>