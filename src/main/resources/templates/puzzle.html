<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="_csrf" th:content="${_csrf.token}"/>
    <meta name="_csrf_header" th:content="${_csrf.headerName}"/>
    <title th:text="${puzzle.name}">Puzzle</title>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"
        integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2"
        crossorigin="anonymous"></script>
    <link rel="stylesheet"
      href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css"
      integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU"
      crossorigin="anonymous">
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"
        integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD"
        crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4ecf7 100%);
            margin: 0;
            padding: 30px 16px 60px;
            color: #1f2d3d;
        }
        .container {
            max-width: 600px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 18px;
        }
        h1 {
            color: #1f2d3d;
            margin-top: 0;
        }
        .difficulty {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
            margin-bottom: 15px;
        }
        .difficulty.EASY {
            background: #d4edda;
            color: #155724;
            padding: 15px;
            border-radius: 12px;
        }
        .difficulty.MEDIUM {
            background: #fff3cd;
            color: #856404;
            padding: 15px;
            border-radius: 12px;
        }
        .difficulty.HARD {
            background: #f8d7da;
            color: #721c24;
            padding: 15px; 
            border-radius: 12px;
        }
        .description {
            background: rgba(31, 120, 255, 0.08);
            padding: 15px;
            border-radius: 12px;
            border-left: 4px solid rgba(31, 120, 255, 0.6);
            margin-bottom: 8px;
            color: #4b6176;
        }
        .turn-indicator {
            text-align: center;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 12px;
            color: #1f2d3d;
        }
        #board {
            width: 100%;
            max-width: 480px;
            margin: 0 auto 20px;
        }
        .actions {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 15px;
        }
        .timer-badge {
            align-self: center;
            font-weight: 600;
            background: rgba(31, 120, 255, 0.14);
            padding: 6px 18px;
            border-radius: 999px;
            color: #1f2d3d;
            letter-spacing: 0.4px;
        }
        .page-nav {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }
        .link-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 8px 16px;
            border-radius: 999px;
            background: #ffffff;
            color: #1f2d3d;
            font-weight: 600;
            text-decoration: none;
            box-shadow: 0 6px 16px rgba(31, 45, 61, 0.12);
            border: 1px solid rgba(31, 45, 61, 0.12);
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .link-button:hover {
            transform: translateY(-1px);
            box-shadow: 0 10px 24px rgba(31, 45, 61, 0.16);
            border-color: rgba(31, 120, 255, 0.4);
        }
        .link-button:focus-visible {
            outline: 3px solid rgba(31, 120, 255, 0.45);
            outline-offset: 2px;
        }
        .back-link-icon {
            width: 10px;
            height: 10px;
            border-left: 2px solid currentColor;
            border-bottom: 2px solid currentColor;
            transform: rotate(45deg);
            margin-right: 2px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-primary:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        #message {
            text-align: center;
            font-size: 16px;
            margin-top: 15px;
            min-height: 24px;
            font-weight: bold;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .dialog-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(17, 24, 39, 0.55);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 16px;
        }
        .dialog-backdrop.visible {
            display: flex;
        }
        .dialog-box {
            width: 100%;
            max-width: 360px;
            background: #ffffff;
            border-radius: 12px;
            padding: 22px 24px;
            box-shadow: 0 24px 48px rgba(17, 24, 39, 0.28);
        }
        .dialog-box h3 {
            margin: 0 0 12px;
            font-size: 18px;
            color: #1f2d3d;
        }
        .dialog-box p {
            margin: 0;
            color: #44556a;
            line-height: 1.45;
        }
        .dialog-buttons {
            margin-top: 22px;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            flex-wrap: wrap;
        }
        .dialog-button {
            padding: 8px 16px;
            border-radius: 6px;
            border: none;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s ease, transform 0.2s ease;
        }
        .dialog-button.primary {
            background: #1f78ff;
            color: #ffffff;
        }
        .dialog-button.primary:hover {
            background: #0f4fbf;
            transform: translateY(-1px);
        }
        .dialog-button.secondary {
            background: #e5e7eb;
            color: #1f2d3d;
        }
        .dialog-button.secondary:hover {
            background: #d1d5db;
            transform: translateY(-1px);
        }
        .dialog-button.danger {
            background: #d9534f;
            color: #ffffff;
        }
        .dialog-button.danger:hover {
            background: #b12b27;
            transform: translateY(-1px);
        }
        .dialog-buttons.promotion-choices {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 74px));
            justify-content: center;
            justify-items: center;
            gap: 14px;
        }
        .dialog-button.piece {
            width: 74px;
            height: 96px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 8px 12px;
            gap: 6px;
            background: #f5f8fc;
            border: 1px solid rgba(31, 120, 255, 0.2);
            color: #1f2d3d;
        }
        .dialog-button.piece:hover {
            background: rgba(31, 120, 255, 0.15);
        }
        .dialog-button.piece img {
            width: 48px;
            height: 48px;
            pointer-events: none;
        }
        .dialog-button.piece span {
            font-size: 13px;
            font-weight: 600;
        }
        .dialog-button.cancel-action {
            grid-column: 1 / -1;
            width: 100%;
            max-width: 220px;
            margin-top: 6px;
            justify-self: center;
        }
        .highlight-move {
            box-shadow: inset 0 0 3px 3px rgba(30, 144, 255, 0.6);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="page-nav">
            <a href="/puzzles" class="link-button">
                <span class="back-link-icon" aria-hidden="true"></span>
                <span>Back to Puzzles</span>
            </a>
            <a href="/games" class="link-button">
                <span class="back-link-icon" aria-hidden="true"></span>
                <span>Back to Games</span>
            </a>
        </div>
        <h1 th:text="${puzzle.name}"></h1>
        <span class="difficulty" th:text="${puzzle.difficulty}" th:classappend="${puzzle.difficulty}"></span>
        <div class="rating-range" th:if="${puzzle.ratingLow != null and puzzle.ratingHigh != null}" style="margin-top: 8px; font-size: 14px; color: #6b7b8a;">
            Suggested rating range:
            <strong th:text="${puzzle.ratingLow}"></strong>
            –
            <strong th:text="${puzzle.ratingHigh}"></strong>
        </div>
        
        <div class="description" th:text="${puzzle.description}"></div>
        
        <div class="turn-indicator">
            <span th:text="${puzzle.turn}"></span> to move
        </div>
        
        <div id="board"></div>
        
        <div class="actions">
            <button class="btn-secondary" onclick="resetPuzzle()">Reset</button>
        </div>
        
        <div class="timer-badge">Solve Time: <span id="timer-display">00:00</span></div>

        <div id="message"></div>

    </div>

    <div id="dialog-backdrop" class="dialog-backdrop">
        <div class="dialog-box" role="dialog" aria-modal="true">
            <h3 id="dialog-title"></h3>
            <p id="dialog-message"></p>
            <div id="dialog-buttons" class="dialog-buttons"></div>
        </div>
    </div>

    <script th:inline="javascript">
        let boardWidget = null;
        let gameLogic = new Chess();
        let moves = [];
        let initialBoardRaw = [[${puzzle.boardState}]];
        let startingBoardMatrix = [];
        let currentBoard = [];
        let playerTurn = [[${puzzle.turn}]];
        let puzzleId = [[${puzzle.id}]];
        let initialFen = '';
        let fenLoaded = false;
        let puzzleCompleted = false;
        let lastBoardBeforeMove = null;
        let dialogBackdrop = null;
        let dialogTitleEl = null;
        let dialogMessageEl = null;
        let dialogButtonsContainer = null;
        let highlightedSquares = [];
        let puzzleStartTime = null;
        let timerIntervalId = null;
        const boardOrientation = playerTurn === 'WHITE' ? 'white' : 'black';
        let promotionSelectionInProgress = false;
        let promotionResolveFn = null;

        const unicodeToFen = {
            '♔': 'K', '♕': 'Q', '♖': 'R', '♗': 'B', '♘': 'N', '♙': 'P',
            '♚': 'k', '♛': 'q', '♜': 'r', '♝': 'b', '♞': 'n', '♟': 'p'
        };

        const fenToUnicode = {
            'K': '♔', 'Q': '♕', 'R': '♖', 'B': '♗', 'N': '♘', 'P': '♙',
            'k': '♚', 'q': '♛', 'r': '♜', 'b': '♝', 'n': '♞', 'p': '♟'
        };

        const PROMOTION_MAP = {
            QUEEN: 'q',
            ROOK: 'r',
            BISHOP: 'b',
            KNIGHT: 'n'
        };

        const PROMOTION_FEN = {
            QUEEN: 'Q',
            ROOK: 'R',
            BISHOP: 'B',
            KNIGHT: 'N'
        };

        const PROMOTION_TYPES = ['QUEEN', 'ROOK', 'BISHOP', 'KNIGHT'];

        function promotionImagePath(pieceColor, promotionType) {
            const prefix = pieceColor === 'b' ? 'b' : 'w';
            const code = PROMOTION_MAP[promotionType];
            if (!code) {
                return null;
            }
            return '/img/chesspieces/wikipedia/' + prefix + code + '.png';
        }

        function promotionLabel(promotionType) {
            return promotionType.charAt(0) + promotionType.slice(1).toLowerCase();
        }

        function buildPromotionButtonHtml(pieceColor, promotionType) {
            const imgSrc = promotionImagePath(pieceColor, promotionType);
            const label = promotionLabel(promotionType);
            if (!imgSrc) {
                return label;
            }
            return '<img src="' + imgSrc + '" alt="' + label + ' piece" /><span>' + label + '</span>';
        }

        function boardToFen(boardState) {
            const rows = [];
            for (let r = 0; r < 8; r++) {
                let fenRow = '';
                let empty = 0;
                for (let c = 0; c < 8; c++) {
                    const cell = normalizeCell(boardState[r][c]);
                    if (!cell) {
                        empty++;
                        continue;
                    }
                    const mapped = unicodeToFen[cell];
                    if (!mapped) {
                        empty++;
                        continue;
                    }
                    if (empty > 0) {
                        fenRow += empty;
                        empty = 0;
                    }
                    fenRow += mapped;
                }
                if (empty > 0) {
                    fenRow += empty;
                }
                rows.push(fenRow);
            }
            return rows.join('/');
        }

        function normalizeCell(value) {
            if (!value) {
                return '';
            }
            const trimmed = typeof value === 'string' ? value.trim() : value;
            if (!trimmed) {
                return '';
            }
            return trimmed;
        }

        function boardFromChess(chessBoard) {
            return chessBoard.map(row => row.map(square => {
                if (!square) return '';
                const key = square.color === 'w' ? square.type.toUpperCase() : square.type.toLowerCase();
                return fenToUnicode[key] || '';
            }));
        }

        function algebraicToRowCol(square) {
            if (!square || square.length !== 2) return null;
            const file = square.charCodeAt(0) - 'a'.charCodeAt(0);
            const rank = parseInt(square[1], 10);
            if (file < 0 || file > 7 || isNaN(rank) || rank < 1 || rank > 8) return null;
            const row = 8 - rank;
            const col = file;
            return { row, col };
        }

        function normalizeSquareName(square) {
            if (!square || typeof square !== 'string') {
                return null;
            }
            const trimmed = square.trim();
            return trimmed.length === 2 ? trimmed.toLowerCase() : null;
        }

        function getPieceColorFromUnicode(symbol) {
            const fenSymbol = unicodeToFen[symbol];
            if (!fenSymbol) {
                return null;
            }
            return fenSymbol === fenSymbol.toUpperCase() ? 'w' : 'b';
        }

        function isPromotionDestination(pieceSymbol, targetRow) {
            const color = getPieceColorFromUnicode(pieceSymbol);
            if (!color) {
                return false;
            }
            const fenSymbol = unicodeToFen[pieceSymbol];
            if (!fenSymbol || fenSymbol.toUpperCase() !== 'P') {
                return false;
            }
            return (color === 'w' && targetRow === 0) || (color === 'b' && targetRow === 7);
        }

        function promotionSymbolFor(pieceSymbol, promotionType) {
            if (!pieceSymbol || !promotionType) {
                return pieceSymbol;
            }
            const fenBase = unicodeToFen[pieceSymbol];
            if (!fenBase) {
                return pieceSymbol;
            }
            const isWhite = fenBase === fenBase.toUpperCase();
            const template = PROMOTION_FEN[promotionType];
            if (!template) {
                return pieceSymbol;
            }
            const fenTarget = isWhite ? template : template.toLowerCase();
            return fenToUnicode[fenTarget] || pieceSymbol;
        }

        function promptPromotionSelection(pieceColor) {
            if (promotionSelectionInProgress) {
                return Promise.resolve(null);
            }
            promotionSelectionInProgress = true;

            return new Promise(resolve => {
                promotionResolveFn = resolve;
                const colorLabel = pieceColor === 'b' ? 'Black' : 'White';
                const finish = choice => {
                    promotionSelectionInProgress = false;
                    if (promotionResolveFn) {
                        const resolver = promotionResolveFn;
                        promotionResolveFn = null;
                        resolver(choice);
                    }
                    hidePuzzleDialog();
                };

                const buttons = PROMOTION_TYPES.map(type => ({
                    html: buildPromotionButtonHtml(pieceColor, type),
                    handler: () => finish(type),
                    variant: 'piece',
                    ariaLabel: 'Promote to ' + promotionLabel(type)
                }));
                buttons.push({ label: 'Cancel', variant: 'secondary cancel-action', handler: () => finish(null) });

                showPuzzleDialog({
                    title: colorLabel + ' pawn promotion',
                    message: 'Select a piece to promote to.',
                    buttons: buttons,
                    buttonsClass: 'promotion-choices'
                });
            });
        }

        function parseInitialBoard() {
            try {
                if (typeof initialBoardRaw === 'string') {
                    return sanitizeBoard(JSON.parse(initialBoardRaw));
                }
                return sanitizeBoard(JSON.parse(JSON.stringify(initialBoardRaw)));
            } catch (error) {
                console.error('Failed to parse puzzle board state', error);
                return Array.from({ length: 8 }, () => Array(8).fill(''));
            }
        }

        function sanitizeBoard(board) {
            if (!Array.isArray(board)) {
                return Array.from({ length: 8 }, () => Array(8).fill(''));
            }
            for (let r = 0; r < 8; r++) {
                if (!Array.isArray(board[r])) {
                    board[r] = Array(8).fill('');
                    continue;
                }
                for (let c = 0; c < 8; c++) {
                    board[r][c] = normalizeCell(board[r][c]);
                }
            }
            return board;
        }

        function initBoard() {
            startingBoardMatrix = parseInitialBoard();
            currentBoard = JSON.parse(JSON.stringify(startingBoardMatrix));
            const placement = boardToFen(currentBoard);
            const turnLetter = playerTurn === 'WHITE' ? 'w' : 'b';
            initialFen = `${placement} ${turnLetter} - - 0 1`; // load puzzle into chess.js for legal move checks
            gameLogic = new Chess();
            fenLoaded = gameLogic.load(initialFen);
            if (!fenLoaded) {
                console.warn('chess.js could not load puzzle FEN:', initialFen);
            } else {
                currentBoard = boardFromChess(gameLogic.board());
            }
            moves = [];
            puzzleCompleted = false;
            lastBoardBeforeMove = null;
            removeHighlights();
            const messageEl = document.getElementById('message');
            if (messageEl) {
                messageEl.textContent = '';
                messageEl.className = '';
            }
            renderBoard();
            startPuzzleTimer();
        }

        function renderBoard() {
            const fenPlacement = fenLoaded ? gameLogic.fen().split(' ')[0] : boardToFen(currentBoard);
            const opts = {
                position: fenPlacement,
                draggable: true,
                orientation: boardOrientation,
                pieceTheme: '/img/chesspieces/wikipedia/{piece}.png',
                onDragStart: handleDragStart,
                onDrop: handleBoardDrop,
                onMouseoverSquare: onMouseoverSquare,
                onMouseoutSquare: onMouseoutSquare
            };
            if (!boardWidget) {
                boardWidget = Chessboard('board', opts);
            } else {
                boardWidget.orientation(boardOrientation);
                boardWidget.position(fenPlacement, false);
            }
        }

        function handleDragStart(source, piece) {
            if (puzzleCompleted) {
                return false;
            }
            removeHighlights();
            if (!piece) return false;

            const isWhitePiece = piece.startsWith('w');
            if (playerTurn === 'WHITE' && !isWhitePiece) return false;
            if (playerTurn === 'BLACK' && isWhitePiece) return false;

            if (!fenLoaded) {
                const coords = algebraicToRowCol(source);
                return coords ? currentBoard[coords.row][coords.col] !== '' : false;
            }

            const squareState = gameLogic.get(source);
            return !!squareState;
        }

        function handleBoardDrop(source, target) {
            if (puzzleCompleted) {
                return 'snapback';
            }
            if (source === target) return 'snapback';

            const normalizedSource = normalizeSquareName(source);
            const normalizedTarget = normalizeSquareName(target);
            if (!normalizedSource || !normalizedTarget) {
                return 'snapback';
            }

            lastBoardBeforeMove = !fenLoaded ? JSON.parse(JSON.stringify(currentBoard)) : null;
            removeHighlights();

            if (!fenLoaded) {
                const fromFallback = algebraicToRowCol(normalizedSource);
                const toFallback = algebraicToRowCol(normalizedTarget);
                if (!fromFallback || !toFallback) return 'snapback';

                const moveData = {
                    fromRow: fromFallback.row,
                    fromCol: fromFallback.col,
                    toRow: toFallback.row,
                    toCol: toFallback.col
                };

                const movingPiece = currentBoard[fromFallback.row][fromFallback.col];
                if (isPromotionDestination(movingPiece, toFallback.row)) {
                    return promptPromotionSelection(getPieceColorFromUnicode(movingPiece))
                        .then(choice => {
                            if (!choice) {
                                renderBoard();
                                return;
                            }
                            const promotedSymbol = promotionSymbolFor(movingPiece, choice);
                            currentBoard[toFallback.row][toFallback.col] = promotedSymbol;
                            currentBoard[fromFallback.row][fromFallback.col] = '';
                            moveData.promotion = choice;
                            moves.push(moveData);
                            boardWidget.position(boardToFen(currentBoard), false);
                            evaluateMoves();
                        });
                }

                moves.push(moveData);

                const piece = currentBoard[fromFallback.row][fromFallback.col];
                currentBoard[toFallback.row][toFallback.col] = piece;
                currentBoard[fromFallback.row][fromFallback.col] = '';
                boardWidget.position(boardToFen(currentBoard), false);
                evaluateMoves();
                return;
            }

            const legalMoves = gameLogic.moves({ square: normalizedSource, verbose: true }) || [];
            const matchingMove = legalMoves.find(mv => mv.to === normalizedTarget);
            if (!matchingMove) {
                return 'snapback';
            }

            const needsPromotion = !!matchingMove.promotion;

            const attemptMove = (promotionChoice) => {
                const moveConfig = {
                    from: normalizedSource,
                    to: normalizedTarget
                };
                if (promotionChoice) {
                    moveConfig.promotion = PROMOTION_MAP[promotionChoice];
                }

                const moveResult = gameLogic.move(moveConfig);
                if (moveResult === null) {
                    return false;
                }

                const from = algebraicToRowCol(normalizedSource);
                const to = algebraicToRowCol(normalizedTarget);
                if (!from || !to) {
                    gameLogic.undo();
                    return false;
                }

                const moveEntry = {
                    fromRow: from.row,
                    fromCol: from.col,
                    toRow: to.row,
                    toCol: to.col
                };
                if (promotionChoice) {
                    moveEntry.promotion = promotionChoice;
                }

                moves.push(moveEntry);

                currentBoard = boardFromChess(gameLogic.board());
                boardWidget.position(gameLogic.fen().split(' ')[0], false);
                evaluateMoves();
                return true;
            };

            if (needsPromotion) {
                const movingPiece = gameLogic.get(normalizedSource);
                if (!movingPiece) {
                    return 'snapback';
                }
                promptPromotionSelection(movingPiece.color).then(choice => {
                    if (!choice) {
                        renderBoard();
                        return;
                    }
                    const success = attemptMove(choice);
                    if (!success) {
                        renderBoard();
                    }
                });
                return 'snapback';
            }

            const moved = attemptMove(null);
            if (!moved) {
                return 'snapback';
            }
        }

        function resetPuzzle() {
            fenLoaded = gameLogic.load(initialFen);
            if (!fenLoaded) {
                console.warn('chess.js could not reload puzzle FEN:', initialFen);
                currentBoard = JSON.parse(JSON.stringify(startingBoardMatrix));
            } else {
                currentBoard = boardFromChess(gameLogic.board());
            }
            moves = [];
            puzzleCompleted = false;
            lastBoardBeforeMove = null;
            const messageEl = document.getElementById('message');
            if (messageEl) {
                messageEl.textContent = '';
                messageEl.className = '';
            }
            hidePuzzleDialog();
            removeHighlights();
            renderBoard();
            startPuzzleTimer();
        }

        async function evaluateMoves() {
            if (moves.length === 0) {
                return;
            }

            try {
                const csrfToken = document.querySelector('meta[name="_csrf"]')?.content;
                const csrfHeader = document.querySelector('meta[name="_csrf_header"]')?.content;

                const headers = { 'Content-Type': 'application/json' };
                if (csrfToken && csrfHeader) {
                    headers[csrfHeader] = csrfToken;
                }

                const response = await fetch(`/api/puzzle/${puzzleId}/check`, {
                    method: 'POST',
                    headers: headers,
                    body: JSON.stringify({
                        moves: moves,
                        elapsedMillis: getElapsedMillis()
                    })
                });

                const result = await response.json();
                const status = (result.status || '').toUpperCase();

                if (status === 'WRONG' || !result.correct) {
                    revertLastMove();
                    showMessage(result.message || 'That move is incorrect.', false);
                    showPuzzleDialog({
                        title: 'Wrong Move',
                        message: result.message || 'That move is incorrect.',
                        buttons: [
                            {
                                label: 'Reset Board',
                                variant: 'danger',
                                handler: () => {
                                    resetPuzzle();
                                }
                            },
                            {
                                label: 'Try Again',
                                variant: 'secondary',
                                handler: hidePuzzleDialog
                            }
                        ]
                    });
                    return;
                }

                if (status === 'SOLVED' || result.solved) {
                    puzzleCompleted = true;
                    stopPuzzleTimer();
                    const recordedSeconds = (result.recordedDurationSeconds !== null && result.recordedDurationSeconds !== undefined)
                        ? result.recordedDurationSeconds
                        : Math.max(1, Math.ceil(getElapsedMillis() / 1000));
                    const formattedSolve = formatSeconds(recordedSeconds);
                    const solvedMessage = result.message || 'Puzzle solved!';
                    const combinedMessage = formattedSolve ? `${solvedMessage} • ${formattedSolve}` : solvedMessage;
                    showMessage(combinedMessage, true);
                    showPuzzleDialog({
                        title: 'Puzzle Solved!',
                        message: formattedSolve ? `${solvedMessage}\nSolved in ${formattedSolve}.` : solvedMessage,
                        buttons: [
                            {
                                label: 'Back to Puzzles',
                                variant: 'primary',
                                handler: () => {
                                    hidePuzzleDialog();
                                    window.location.href = '/puzzles';
                                }
                            },
                            {
                                label: 'Replay Puzzle',
                                variant: 'secondary',
                                handler: () => {
                                    resetPuzzle();
                                }
                            }
                        ]
                    });
                    return;
                }

                if (status === 'PROGRESS') {
                    showMessage(result.message || 'Correct move! Keep going.', true);
                    showPuzzleDialog({
                        title: 'Correct Move',
                        message: result.message || 'That move is correct. Continue the sequence.',
                        buttons: [
                            {
                                label: 'Keep Going',
                                variant: 'primary',
                                handler: hidePuzzleDialog
                            },
                            {
                                label: 'Reset Board',
                                variant: 'secondary',
                                handler: () => {
                                    resetPuzzle();
                                }
                            }
                        ]
                    });
                    return;
                }

                showMessage(result.message || 'Unable to verify move right now.', false);
            } catch (error) {
                showMessage('Unable to verify move right now.', false);
            }
        }

        function revertLastMove() {
            if (moves.length > 0) {
                moves.pop();
            }

            if (fenLoaded) {
                const undone = gameLogic.undo();
                if (undone) {
                    currentBoard = boardFromChess(gameLogic.board());
                    boardWidget.position(gameLogic.fen().split(' ')[0], false);
                }
            } else if (lastBoardBeforeMove) {
                currentBoard = JSON.parse(JSON.stringify(lastBoardBeforeMove));
                boardWidget.position(boardToFen(currentBoard), false);
            }
            lastBoardBeforeMove = null;
        }

        function onMouseoverSquare(square, piece) {
            if (puzzleCompleted) {
                return;
            }
            if (!fenLoaded) {
                return;
            }
            removeHighlights();
            if (!piece) {
                return;
            }
            const moves = gameLogic.moves({ square: square, verbose: true }) || [];
            if (moves.length === 0) {
                return;
            }
            highlightSquare(square);
            moves.forEach(move => {
                highlightSquare(move.to);
            });
        }

        function onMouseoutSquare(square, piece) {
            removeHighlights();
        }

        function highlightSquare(square) {
            if (!square) {
                return;
            }
            const el = document.querySelector('.square-' + square);
            if (!el) {
                return;
            }
            el.classList.add('highlight-move');
            highlightedSquares.push(el);
        }

        function removeHighlights() {
            if (!highlightedSquares.length) {
                const activeHighlights = document.querySelectorAll('.highlight-move');
                activeHighlights.forEach(el => el.classList.remove('highlight-move'));
                highlightedSquares = [];
                return;
            }
            highlightedSquares.forEach(el => el.classList.remove('highlight-move'));
            highlightedSquares = [];
        }

        function formatSeconds(seconds) {
            if (seconds === null || seconds === undefined || isNaN(seconds)) {
                return null;
            }
            const totalSeconds = Math.max(0, Math.round(seconds));
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const secs = totalSeconds % 60;
            if (hours > 0) {
                return [hours, minutes, secs].map(unit => unit.toString().padStart(2, '0')).join(':');
            }
            return `${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerDisplay(elapsedMs) {
            const display = document.getElementById('timer-display');
            if (!display) {
                return;
            }
            const formatted = formatSeconds(Math.floor(Math.max(0, elapsedMs || 0) / 1000));
            display.textContent = formatted || '00:00';
        }

        function getElapsedMillis() {
            if (!puzzleStartTime) {
                return 0;
            }
            return Date.now() - puzzleStartTime;
        }

        function startPuzzleTimer() {
            stopPuzzleTimer();
            puzzleStartTime = Date.now();
            updateTimerDisplay(0);
            timerIntervalId = window.setInterval(() => {
                updateTimerDisplay(getElapsedMillis());
            }, 1000);
        }

        function stopPuzzleTimer() {
            if (timerIntervalId) {
                window.clearInterval(timerIntervalId);
                timerIntervalId = null;
            }
            if (puzzleStartTime) {
                updateTimerDisplay(getElapsedMillis());
            }
        }

        function showMessage(text, isSuccess) {
            const messageEl = document.getElementById('message');
            if (!messageEl) {
                return;
            }
            messageEl.textContent = text || '';
            if (!text) {
                messageEl.className = '';
                return;
            }
            messageEl.className = isSuccess ? 'success' : 'error';
        }

        function showPuzzleDialog(config) {
            if (!dialogBackdrop) {
                return;
            }
            dialogTitleEl.textContent = config.title || '';
            dialogMessageEl.textContent = config.message || '';

            while (dialogButtonsContainer.firstChild) {
                dialogButtonsContainer.removeChild(dialogButtonsContainer.firstChild);
            }

            const extraClass = config.buttonsClass ? ' ' + config.buttonsClass : '';
            dialogButtonsContainer.className = 'dialog-buttons' + extraClass;

            (config.buttons || []).forEach(button => {
                const btn = document.createElement('button');
                btn.className = 'dialog-button ' + (button.variant || 'secondary');
                if (button.html) {
                    btn.innerHTML = button.html;
                    if (button.ariaLabel) {
                        btn.setAttribute('aria-label', button.ariaLabel);
                    }
                } else {
                    btn.textContent = button.label || 'OK';
                }
                btn.addEventListener('click', () => {
                    if (typeof button.handler === 'function') {
                        button.handler();
                    } else {
                        hidePuzzleDialog();
                    }
                });
                dialogButtonsContainer.appendChild(btn);
            });

            if (!dialogButtonsContainer.firstChild) {
                const fallbackBtn = document.createElement('button');
                fallbackBtn.className = 'dialog-button primary';
                fallbackBtn.textContent = 'OK';
                fallbackBtn.addEventListener('click', hidePuzzleDialog);
                dialogButtonsContainer.appendChild(fallbackBtn);
            }

            dialogBackdrop.classList.add('visible');
        }

        function hidePuzzleDialog() {
            if (dialogBackdrop) {
                dialogBackdrop.classList.remove('visible');
            }
            if (promotionSelectionInProgress) {
                if (promotionResolveFn) {
                    const resolver = promotionResolveFn;
                    promotionResolveFn = null;
                    promotionSelectionInProgress = false;
                    resolver(null);
                } else {
                    promotionSelectionInProgress = false;
                }
            }
        }

        window.onload = function() {
            dialogBackdrop = document.getElementById('dialog-backdrop');
            dialogTitleEl = document.getElementById('dialog-title');
            dialogMessageEl = document.getElementById('dialog-message');
            dialogButtonsContainer = document.getElementById('dialog-buttons');
            if (dialogBackdrop) {
                dialogBackdrop.addEventListener('click', function(event) {
                    if (event.target === dialogBackdrop) {
                        hidePuzzleDialog();
                    }
                });
            }
            initBoard();
        };
    </script>
</body>
</html>
